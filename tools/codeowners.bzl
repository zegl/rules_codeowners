def _codeowners_impl(ctx):
    path = "/" + ctx.label.package + "/"

    # The PATH will be set to the empty string,
    # if the codeowners is defined in the ROOT of the WORKSPACE
    if ctx.label.package == "":
        path = ""

    if len(ctx.attr.team) == 0 and len(ctx.attr.teams) == 0:
        fail("Either team or teams must be set.")
    if len(ctx.attr.team) > 0 and len(ctx.attr.teams) > 0:
        fail("Both team and teams can not be set at the same time.")

    env = {
        "OUTFILE": ctx.outputs.outfile.path,
        "PATH": path,
    }

    if len(ctx.attr.team) > 0:
        env.update({"TEAMS": ctx.attr.team})
    else:
        env.update({"TEAMS": " ".join(ctx.attr.teams)})

    # Add optional extra pattern
    if ctx.attr.pattern:
        env.update({"PATTERN": ctx.attr.pattern})

    ctx.actions.run_shell(
        outputs = [ctx.outputs.outfile],
        command = """
set -euo pipefail

echo "${PATH}${PATTERN:-} $TEAMS" > "$OUTFILE"
""",
        env = env,
    )

codeowners = rule(
    implementation = _codeowners_impl,
    attrs = {
        "team": attr.string(mandatory = False, doc = "The GitHub team that should get ownership of the matching files. One of team and teams must be set."),
        "teams": attr.string_list(mandatory = False, doc = "A list of the GitHub teams that should get ownership of the matching files. One of team and teams must be set."),
        "pattern": attr.string(mandatory = False),
    },
    outputs = {
        "outfile": "%{name}.out",
    },
)

def _generate_codeowners_impl(ctx):
    all_ownerships = []
    all_ownerships_files = []
    for owner in ctx.attr.owners:
        all_ownerships.append(owner.files.to_list()[0].path)
        all_ownerships_files.append(owner.files.to_list()[0])

    unsorted_tmp_file = ctx.actions.declare_file(ctx.label.name + "_unsorted")

    ctx.actions.run_shell(
        outputs = [ctx.outputs.outfile, unsorted_tmp_file],
        inputs = all_ownerships_files,
        arguments = all_ownerships,
        env = {
            "OUTFILE": ctx.outputs.outfile.path,
            "UNSORTED_FILE": unsorted_tmp_file.path,
            "SORT": "true" if ctx.attr.sort else "false"
        },
        command = """
set -euo pipefail

echo "# This file was generated by rules_codeowners / Bazel" >> "$OUTFILE"
echo "# Don't edit it directly" >> "$OUTFILE"
echo "" >> "$OUTFILE"

for file in "$@"
do
    cat "$file" >> "$UNSORTED_FILE"
done

# Optional sorting, the most specific rule will appear last in the output
if "$SORT"; then
    cat "$UNSORTED_FILE" | sort >> "$OUTFILE"
else
    cat "$UNSORTED_FILE" >> "$OUTFILE"
fi
""",
    )

generate_codeowners = rule(
    implementation = _generate_codeowners_impl,
    attrs = {
        "owners": attr.label_list(),
        "sort": attr.bool(default = False, mandatory = False),
    },
    outputs = {
        "outfile": "%{name}.out",
    },
)
